#!/bin/bash

DEST="/usr/local/bin/pmenu"

if [[ $0 != "$DEST" ]]; then

    chmod +x "$0"
    sudo mv "$0" "$DEST"
    clear
    echo -e "\033[1;33mINSTALADO COM SUCESSO DIGITE \033[1;37mpmenu \033[1;33mPARA ACESSAR"
    exit 0
fi

function remover() {

DEST="/usr/local/bin/pmenu"

if [[ -f "$DEST" ]]; then

    sudo rm "$DEST"
    echo -e "\033[1;31mSCRIPT REMOVIDO COM SUCESSO"
    echo "Script pmenu não encontrado em $DEST."
fi

}

function cloudflare() {

# Configurações
API_TOKEN="0aBhiCWTz7dqL1Wj4yUgm2ixyU8FVpooc0wVQd9g"
ZONE_ID="1f33ec47046958af29ba67ac0156314a"
DOMAIN="dtmod.site"
RECORD_TYPE="A"  # Tipo de registro, por exemplo, A, CNAME
TTL=1            # Time-to-live no modo auto

# Função para obter o IP do servidor
get_server_ip() {
  curl -s http://checkip.amazonaws.com/
}

# Obter o IP do servidor
CONTENT=$(get_server_ip)

# Verifica se o subdomínio já existe
check_subdomain_exists() {
  SUBDOMAIN=$1
  API_ENDPOINT="https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=$RECORD_TYPE&name=$SUBDOMAIN.$DOMAIN"
  response=$(curl -s -X GET "$API_ENDPOINT" \
    -H "Authorization: Bearer $API_TOKEN" \
    -H "Content-Type: application/json")
  echo "$response" | grep -q '"count":1'
}

# Solicitar o prefixo do subdomínio
while true; do
  read -p "Digite o prefixo do subdomínio: " SUBDOMAIN

  if check_subdomain_exists "$SUBDOMAIN"; then
    echo "Subdomínio $SUBDOMAIN.$DOMAIN já existe. Por favor, escolha outro prefixo."
  else
    break
  fi
done

# Solicitar se deseja habilitar o proxy
while true; do
  read -p "Deseja habilitar o proxy da Cloudflare para este subdomínio? (s/n): " PROXY_CHOICE
  case $PROXY_CHOICE in
    [sS]* ) PROXIED=true; break;;
    [nN]* ) PROXIED=false; break;;
    * ) echo "Por favor, responda s (sim) ou n (não).";;
  esac
done

# Endpoint da API da Cloudflare para criar DNS record
API_ENDPOINT="https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records"

# Dados para o novo registro DNS
DATA=$(cat <<EOF
{
  "type": "$RECORD_TYPE",
  "name": "$SUBDOMAIN.$DOMAIN",
  "content": "$CONTENT",
  "ttl": $TTL,
  "proxied": $PROXIED
}
EOF
)

# Criar o subdomínio usando a API da Cloudflare
response=$(curl -s -X POST "$API_ENDPOINT" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "Content-Type: application/json" \
  --data "$DATA")

# Verificar se o subdomínio foi criado com sucesso
if echo "$response" | grep -q '"success":true'; then
  echo "Subdomínio $SUBDOMAIN.$DOMAIN criado com sucesso."
else
  echo "Falha ao criar o subdomínio. Resposta da API:"
  echo "$response"
  exit 1
fi

# Perguntar sobre CNAME independentemente do proxy
while true; do
  read -p "Deseja criar um CNAME para este subdomínio? (s/n): " CNAME_CHOICE
  case $CNAME_CHOICE in
    [sS]* ) 
      # Solicitar se deseja habilitar o proxy para o CNAME
      while true; do
        read -p "Deseja habilitar o proxy da Cloudflare para o CNAME? (s/n): " CNAME_PROXY_CHOICE
        case $CNAME_PROXY_CHOICE in
          [sS]* ) CNAME_PROXIED=true; break;;
          [nN]* ) CNAME_PROXIED=false; break;;
          * ) echo "Por favor, responda s (sim) ou n (não).";;
        esac
      done

      CNAME_ENDPOINT="https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records"
      CNAME_DATA=$(cat <<EOF
{
  "type": "CNAME",
  "name": "cname.$SUBDOMAIN.$DOMAIN",
  "content": "$SUBDOMAIN.$DOMAIN",
  "ttl": $TTL,
  "proxied": $CNAME_PROXIED
}
EOF
)

      # Criar o CNAME usando a API da Cloudflare
      cname_response=$(curl -s -X POST "$CNAME_ENDPOINT" \
        -H "Authorization: Bearer $API_TOKEN" \
        -H "Content-Type: application/json" \
        --data "$CNAME_DATA")

      # Verificar se o CNAME foi criado com sucesso
      if echo "$cname_response" | grep -q '"success":true'; then
        echo "CNAME cname.$SUBDOMAIN.$DOMAIN criado com sucesso."
      else
        echo "Falha ao criar o CNAME. Resposta da API:"
        echo "$cname_response"
      fi
      break;;
    [nN]* ) break;;
    * ) echo "Por favor, responda s (sim) ou n (não).";;
  esac
done

}

function ssl() {
    if netstat -nltp | grep 'stunnel4' 1>/dev/null 2>/dev/null; then
        [[ $(netstat -nltp | grep 'stunnel4' | wc -l) != '0' ]] && sslt=$(netstat -nplt | grep stunnel4 | awk {'print $4'} | awk -F ":" {'print $2'} | xargs) || sslt="\033[1;31mINDISPONIVEL"
        clear
        echo -e "\033[1;31m╔══════════════════════════════════════╗\033[0m"
    echo -e "\033[01;31m║\E\033[44;1;37m             SSL TUNNEL              \E\033[0m\033[01;31m║"
    echo -e "\033[1;31m╚══════════════════════════════════════╝\033[0m"
        echo -e "\n\033[1;33mPORTAS\033[1;37m: \033[1;32m$sslt"
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mALTERAR PORTA SSL\033[0m"
        echo -e "\033[1;31m[\033[1;36m2\033[1;31m] \033[1;37m• \033[1;33mREMOVER SSL\033[0m"
        echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
        echo ""
        echo -ne "\033[1;32mO QUE DESEJA FAZER \033[1;33m? \033[1;37m"
        read resposta
        echo ""
        if [ "$resposta" = '1' ]; then
            echo -ne "\033[1;32mALTERANDO PORTA SSL!\033[0m"
            porta="443"  # Porta SSL padrão
            verif_ptrs $porta
            var2=$(grep 'accept' /etc/stunnel/stunnel.conf | awk '{print $NF}')
            sed -i "s/\b$var2\b/$porta/g" /etc/stunnel/stunnel.conf >/dev/null 2>&1
            echo ""
            echo -e "\033[1;32mREINICIANDO SSL\n"
            service stunnel4 restart
            echo ""
            netstat -nltp | grep 'stunnel4' >/dev/null && echo -e "\033[1;32mPORTA ALTERADA COM SUCESSO !" || echo -e "\033[1;31mERRO INESPERADO!"
            sleep 3.5s
            clear
            ssl
        elif [ "$resposta" = '0' ]; then
            echo -e "\033[1;31mRetornando...\033[0m"
            sleep 3
            pmenu
        elif [ "$resposta" = '2' ]; then
            echo -e "\033[1;32mREMOVENDO O SSL!\033[0m"
            del_ssl() {
                service stunnel4 stop
                apt-get remove stunnel4 -y
                apt-get autoremove stunnel4 -y
                apt-get purge stunnel4 -y
                rm -rf /etc/stunnel/stunnel.conf
                rm -rf /etc/default/stunnel4
                rm -rf /etc/stunnel/cert.cert
                rm -rf /etc/stunnel/key.key
            }
            echo ""
            del_ssl
            echo ""
            echo -e "\033[1;32mSSL REMOVIDO COM SUCESSO!\033[0m"
            sleep 3
            ssl
        else
            echo ""
            echo -e "\033[1;31mOpção inválida!\033[0m"
            sleep 1
            ssl
        fi
    else
        clear
        echo -e "\033[1;31m╔══════════════════════════════════════╗\033[0m"
    echo -e "\033[01;31m║\E\033[44;1;37m             SSL TUNNEL               \E\033[0m\033[01;31m║"
    echo -e "\033[1;31m╚══════════════════════════════════════╝\033[0m"
        echo ""
        echo -e "\033[1;31m[\033[1;36m1\033[1;31m] \033[1;37m• \033[1;33mINSTALAR\033[0m"
        echo -e "\033[1;31m[\033[1;36m0\033[1;31m] \033[1;37m• \033[1;33mVOLTAR\033[0m"
        echo ""
        echo -ne "\033[1;32mO QUE DESEJA FAZER \033[1;33m? \033[1;37m"
        read resposta
        echo ""
        if [ "$resposta" = '1' ]; then
            portssl='80'
        elif [ "$resposta" = '0' ]; then
            echo -e "\033[1;31mRetornando...\033[0m"
            sleep 3
            pmenu
        else
            echo ""
            echo -e "\033[1;31mOpção inválida!\033[0m"
            sleep 1
            ssl
        fi
        clear
        echo -e "\E[44;1;37m           INSTALADOR SSL             \E[0m"
        echo -e "\n\033[1;33mVOCÊ ESTÁ PRESTES A INSTALAR O SSL TUNNEL!\033[0m"
        echo ""
        echo -ne "\033[1;32mDESEJA CONTINUAR \033[1;31m? \033[1;33m[s/n]:\033[1;37m "
        read resposta
        if [ "$resposta" = 's' ]; then
            echo -e "\n\033[1;33mDEFINA UMA PORTA PARA O SSL TUNNEL!\033[0m"
            echo ""
            read -p "$(echo -e "\033[1;32mQUAL PORTA DESEJA UTILIZAR? \033[1;37m")" -e -i 443 porta
            if [ -z "$porta" ]; then
                echo ""
                echo -e "\033[1;31mPorta inválida!"
                sleep 3
                clear
                ssl
            fi
            verif_ptrs $porta
            echo -e "\n\033[1;32mINSTALANDO O SSL TUNNEL!\033[1;33m"
            echo ""
            apt-get update -y
            apt-get install stunnel4 -y
            echo -e "\n\033[1;32mCONFIGURANDO O SSL TUNNEL!\033[0m"
            echo ""
            ssl_certif() {
                crt='EC'
                openssl genrsa -out key.pem 2048 >/dev/null 2>&1
                (
                    echo $crt
                    echo $crt
                    echo $crt
                    echo $crt
                    echo $crt
                    echo $crt
                    echo $crt
                    echo $crt
                    echo $crt
                ) | openssl req -new -x509 -key key.pem -out cert.pem -days 1050 >/dev/null 2>&1
                cat cert.pem key.pem >>/etc/stunnel/stunnel.pem
                rm key.pem cert.pem >/dev/null 2>&1
                sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
            }

            ssl_certif

            echo -e "\n\033[1;32mINICIANDO O SSL!\033[0m"
            echo ""

            service stunnel4 restart
            service ssh restart
            /etc/init.d/stunnel4 restart

            echo -e "\n\033[1;32mSSL INSTALADO COM SUCESSO! PORTA: \033[1;33m$porta\033[0m"
            sleep 1
            clear

            cd /etc/stunnel/
            rm -rf stunnel.conf
            rm -rf stunnel.pem
            wget https://raw.githubusercontent.com/kiritosshxd/SSHPLUS/master/Install/cert
            wget https://raw.githubusercontent.com/kiritosshxd/SSHPLUS/master/Install/key
            wget https://raw.githubusercontent.com/kiritosshxd/SSHPLUS/master/Install/stunnel
            mv cert cert.pem
            mv key key.pem
            mv stunnel stunnel.conf
            chmod 777 cert.pem
            chmod 777 key.pem
            chmod 777 stunnel.conf
            service stunnel4 restart
            cd $HOME
            clear
            sleep 2
            clear
            ssl
        else
            echo -e "\n\033[1;31mRetornando...\033[0m"
            sleep 2
            clear
            ssl
        fi
    fi
}

function websocket() {
    while true; do
        clear
       
        if ps aux | grep -q "[w]ebsocket"; then
            var_wss="\033[1;32mATIVADO"
        else
            var_wss="\033[1;31mDESATIVADO"
        fi
        
        echo -e "\033[1;31m╔════════════════════════════════════════════════╗\033[0m"
        echo -e "\033[01;31m║                  WEBSOCKET                     ║"
        echo -e "\033[1;31m╚════════════════════════════════════════════════╝\033[0m"
        echo -e "\033[01;31m\033[0m"
        echo -e "\033[1;33mSTATUS [$var_wss\033[1;33m]"
        echo -e "\033[01;31m\033[0m"
        echo -e "\033[1;31m[\033[1;36m01\033[1;31m] \033[1;37m• \033[1;33mINSTALAR WEBSOCKET"
        echo -e "\033[1;31m[\033[1;36m02\033[1;31m] \033[1;37m• \033[1;33mDESINSTALAR"
        echo -e "\033[1;31m[\033[1;36m03\033[1;31m] \033[1;37m• \033[1;33mABRIR PORTA"
        echo -e "\033[1;31m[\033[1;36m00\033[1;31m] \033[1;37m• \033[1;33mRETORNAR AO MENU"
        echo -e "\033[01;31m\033[0m"
        tput civis
        echo -ne "\033[1;32mINFORME UMA OPÇÃO\033[1;37m: ";
        read x
        tput cnorm
        clear
        case $x in
            1 | 01)
                clear
                echo "Baixando o arquivo..."
                clear
                wget -O websocket2.sh https://www.dropbox.com/scl/fi/14hkf24lpjhn90y7xue2s/websocket2.sh?rlkey=pb3p5cha8h8od6ymmqs8l1syg&dl=0
                clear
                echo "Definindo permissões..."
                clear
                chmod +x websocket2.sh
                clear
                echo "Instalando dependências..."
                clear
                apt install dos2unix screen -y
                clear
                echo "Convertendo formato do arquivo..."
                clear
                dos2unix websocket2.sh
                echo "WEBSOCKET INSTALADO"
                sleep 0.3
                ;;
            2 | 02)
    pkill -f "websocket2.sh"
    rm /root/websocket2.sh
    echo "DESINSTALAÇÃO CONCLUÍDA COM SUCESSO!"
    sleep 1
    ;;
            3 | 03)
                chmod +x websocket2.sh
                clear
                echo -n "INFORME A PORTA: "
                read port
                nohup ./websocket2.sh -proxy_port 0.0.0.0:$port &
                ;;
            0 | 00)
                pmenu
                ;;
            *)
                echo -e "\n\033[1;31mOpção inválida!\033[0m"
        esac
        sleep 2
    done
}

function badvpn() {
    clear
    echo -e "\E[44;1;37m            GERENCIAR BADVPN             \E[0m"
    if ps x | grep -w udpvpn | grep -v grep 1>/dev/null 2>/dev/null; then
        echo -e "\033[1;33mPORTAS\033[1;37m: \033[1;32m$(netstat -nplt | grep 'badvpn-ud' | awk {'print $4'} | cut -d: -f2 | xargs)"
    else
        sleep 0.1
    fi
    var_sks1=$(ps x | grep "udpvpn"|grep -v grep > /dev/null && echo -e "\033[1;32m(◉) " || echo -e "\033[1;31m(○)")
echo -e ""
    echo -e "\033[1;31m[\033[1;34m01\033[1;31m] \033[1;37m• \033[1;33mATIVAR BADVPN $var_sks1 \033[0m"
    echo -e "\033[1;31m[\033[1;34m02\033[1;31m] \033[1;37m• \033[1;33mABRIR PORTAS \033[0m"
    echo -e "\033[1;31m[\033[1;34m00\033[1;31m] \033[1;37m• \033[1;33mSAIR \033[0m"
echo -e ""
    echo -ne "\033[1;32mESCOLHA UM NUMERO\033[1;37m: "; read resposta
    if [[ "$resposta" = '1' ]]; then
        if ps x | grep -w udpvpn | grep -v grep 1>/dev/null 2>/dev/null; then
            clear
            echo -e "\E[41;1;37m             BADVPN              \E[0m"
            echo ""
            fun_stopbad () {
                sleep 1
                for pidudpvpn in $(screen -ls | grep ".udpvpn" | awk {'print $1'}); do
                    screen -r -S "$pidudpvpn" -X quit
				done
                [[ $(grep -wc "udpvpn" /etc/autostart) != '0' ]] && {
                    sed -i '/udpvpn/d' /etc/autostart
                }
                sleep 1
                screen -wipe >/dev/null
            }
            echo -e "\033[1;33mPARANDO O BADVPN\033[1;33m"
            echo ""
            fun_stopbad
            echo -e "\033[1;32mBADVPN DESLIGADO COM SUCESSO!\033[1;33m"
            sleep 2s
            badvpn
        else
            clear
            echo -e "\033[1;32mINICIANDO O BADVPN... \033[0m\n"
            fun_udpon () {
                screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7100 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000
screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7200 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000
screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7300 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000
screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7400 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000
screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7500 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000
                [[ $(grep -wc "udpvpn" /etc/autostart) = '0' ]] && {
                    echo -e "ps x | grep 'udpvpn' | grep -v 'grep' || screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7300 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000" >> /etc/autostart
                } || {
                    sed -i '/udpvpn/d' /etc/autostart
                    echo -e "ps x | grep 'udpvpn' | grep -v 'grep' || screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:7300 --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000" >> /etc/autostart
                }
                sleep 1
            }
            inst_udp () {
                [[ -e "/bin/badvpn-udpgw" ]] && {
                    sleep 0.1
                } || {
                    cd $HOME
                    wget https://github.com/BGXSJYRABJE/hdisbsi/raw/main/BADVPN%20UDP/badvpn-udpgw > /dev/null 2>&1
                    mv -f $HOME/badvpn-udpgw /bin/badvpn-udpgw
                    chmod +x /bin/badvpn-udpgw
                }
            }
            inst_udp
            fun_udpon
            echo -e "\033[1;32mBADVPN ATIVADO COM SUCESSO!\033[1;33m"
            sleep 3
            badvpn
        fi
    elif [[ "$resposta" = '2' ]]; then
        if ps x | grep -w udpvpn | grep -v grep 1>/dev/null 2>/dev/null; then
            clear
            echo -e "\E[44;1;37m            BADVPN             \E[0m"
            echo ""
            echo -ne "\033[1;33mQUAL PORTA DESEJA ULTILIZAR \033[1;33m?\033[1;37m: "
            read porta
            [[ -z "$porta" ]] && {
                echo ""
                echo -e "\033[1;31mPorta invalida!"
                sleep 2
                clear
                badvpn
            }
            echo ""
            echo -e "\033[1;33mINICIANDO O BADVPN NA PORTA \033[1;36m$porta\033[1;33m"
            fun_abrirptbad() {
                sleep 1
                screen -dmS udpvpn /bin/badvpn-udpgw --listen-addr 127.0.0.1:$porta --max-clients 16384 --max-connections-for-client 5 --client-socket-sndbuf 16384 --udp-mtu 9000
                sleep 1
            }
            fun_abrirptbad
            echo ""
            echo -e "\033[1;32mBADVPN ATIVADO COM SUCESSO\033[1;33m"
            sleep 2
            badvpn
        else
            clear
            echo -e "\033[1;31mFUNCAO INDISPONIVEL\n\n\033[1;33mATIVE O BADVPN PRIMEIRO !\033[1;33m"
            sleep 2
            badvpn
        fi
    elif [[ "$resposta" = '0' ]]; then
        echo ""
        pmenu
    else
        echo ""
        echo -e "\033[1;31mOpcao invalida !\033[0m"
        sleep 1
        badvpn
    fi
}

function pcheckuser() {
clear
        echo -e "\033[1;31m╔══════════════════════════════════════╗\033[0m"
        echo -e "\033[01;31m║\E\033[44;1;37m             CHECK LOCKED             \E\033[0m\033[01;31m║"
        echo -e "\033[1;31m╚══════════════════════════════════════╝\033[0m"
        echo -e ""

        # Defina a variável var_link como vazia
        var_link=""

        # Verifique se a porta está em uso
        if lsof -i :8888 | grep -q "python3"; then
            var_link+="\033[1;36mD-TUNNEL \033[1;37mE \033[1;36mCONECTA4G\033[1;37m : http://\033[1;32mSEUIP\033[1;37m:8888/checkUser\n"
            var_link+="\033[1;36mGL-TUNNEL\033[1;37m : http://\033[1;32mSEUIP\033[1;37m:8888/gl\n"
            var_link+="\033[1;36mANY MOD\033[1;37m : http://\033[1;32mSEUIP\033[1;37m:8888/anymod"
        else
            var_link="\033[1;31m❌ DESATIVADO ❌"
        fi

        echo -e "$var_link"

        port=8888

        # Verifique se a porta está em uso
        if lsof -i :$port | grep -q "python3"; then
            var_check="\033[1;32m(◉) "
        else
            var_check="\033[1;31m(○)"
        fi

        echo -e ""
        echo -e "\033[1;31m[\033[1;34m01\033[1;31m] \033[1;37m• \033[1;33mINSTALAR"
        echo -e "\033[1;31m[\033[1;34m02\033[1;31m] \033[1;37m• \033[1;33mCHECKUSER $var_check"
        echo -e "\033[1;31m[\033[1;34m03\033[1;31m] \033[1;37m• \033[1;33mDESINSTALAR"
        echo -e "\033[1;31m[\033[1;34m00\033[1;31m] \033[1;37m• \033[1;31mSAIR\033[0m"
        echo -e ""

        echo -ne "\033[1;32mESCOLHA UM NUMERO\033[1;37m: "; read resposta
if [[ "$resposta" = '1' ]]; then
    wget $HOME -O checkuser.py https://www.dropbox.com/scl/fi/xfwy2qlq23dgnjt3all2m/checkuser.py?rlkey=qh87r15fzpald79kziu9kv2um&dl=0    
    sudo apt update
    sudo apt install -y python3-pip curl
    pip3 install flask
    sleep 3
    pcheckuser
elif [[ "$resposta" = '2' ]]; then
    sudo chmod 777 checkuser.py
    nohup python3 checkuser.py &
    clear
    sleep 3
    pcheckuser
elif [[ "$resposta" = '3' ]]; then
    # Verifique se a porta 8888 está em uso pelo python3
    if lsof -i :8888 | grep -q "python3"; then
        # Encontre o PID do processo Python3 que está usando a porta 8888
        python3_pid=$(lsof -t -i :8888)

        # Encerre o processo Python3 usando o PID
        kill -9 "$python3_pid"
        echo "Servidor Python3 na porta 8888 foi encerrado."
    else
        echo "Nenhum servidor Python3 estava em execução na porta 8888."
        clear
        sleep 2
        pcheckuser
    fi
elif [[ "$resposta" = '0' ]]; then
    echo ""
    pmenu
else
    echo ""
    echo -e "\033[1;31mOpcao invalida !\033[0m"
    sleep 1
    pcheckuser
fi

}

function proxy() {
    clear
    echo -e "\033[1;31m╔══════════════════════════════════════╗\033[0m"
    echo -e "\033[01;31m║\E\033[44;1;37m             PROXY LOCKED             \E\033[0m\033[01;31m║"
    echo -e "\033[1;31m╚══════════════════════════════════════╝\033[0m"
    echo -e ""

    echo -e ""
    echo -e "\033[1;31m[\033[1;34m01\033[1;31m] \033[1;37m• \033[1;33mINSTALAR"
    echo -e "\033[1;31m[\033[1;34m02\033[1;31m] \033[1;37m• \033[1;33mDESINSTALAR"
    echo -e "\033[1;31m[\033[1;34m03\033[1;31m] \033[1;37m• \033[1;33mABRIR PORTAS"
    echo -e "\033[1;31m[\033[1;34m04\033[1;31m] \033[1;37m• \033[1;33mABRIR PORTAS SSL"
    echo -e "\033[1;31m[\033[1;34m05\033[1;31m] \033[1;37m• \033[1;33mFECHAR PORTAS"
    echo -e "\033[1;31m[\033[1;34m00\033[1;31m] \033[1;37m• \033[1;31mSAIR\033[0m"
    echo -e ""

    echo -ne "\033[1;32mESCOLHA UM NUMERO\033[1;37m: "; read resposta
    if [[ "$resposta" = '1' ]]; then
        rm -f /usr/bin/proxy
        curl -s -L -o /usr/bin/proxy https://github.com/Lockednet/PROXY/raw/main/proxy
        chmod +x /usr/bin/proxy
        clear
        sleep 3
        proxy
    elif [[ "$resposta" = '2' ]]; then
        if screen -ls | grep -q "\.proxy"; then
            screen -ls | awk '/\.proxy/ {print $1}' | while read -r session; do
                screen -X -S "${session}" quit
            done
            echo "Todas as portas foram desativadas com sucesso."
        else
            echo "Não há portas ativadas pelo proxy."
        fi
        clear
        sleep 3
        proxy
    elif [[ "$resposta" = '3' ]]; then
        echo "Digite o número da porta:"
        read -p "Porta: " porta
        if screen -ls | grep -q "\.$porta\.proxy"; then
            echo "A porta $porta já está ativada."
        else
            screen -dmS $porta.proxy proxy --http --port $porta --ssh-only --response LOCKED
            echo "A porta $porta foi ativada com sucesso."
            clear
            sleep 2
            proxy
        fi
    elif [[ "$resposta" = '4' ]]; then
        echo "Digite o número da porta SSL:"
        read -p "Porta: " porta
        if screen -ls | grep -q "\.$porta\.proxy"; then
            echo "A porta $porta já está ativada."
        else
            screen -dmS $porta.proxy proxy --https --port $porta --cert /root/cert.pem --response LOCKED-SSL
            echo "A porta $porta foi ativada com sucesso."
            clear
            sleep 2
            proxy
        fi     
    elif [[ "$resposta" = '5' ]]; then
        echo "Digite o número da porta a ser desativada:"
        read -p "Porta: " porta
        if screen -ls | grep -q "\.$porta\.proxy"; then
            screen -X -S $porta.proxy quit
            echo "A porta $porta foi desativada com sucesso."
        else
            echo "A porta $porta não está ativada."
        fi
    elif [[ "$resposta" = '0' ]]; then
        echo ""
        pmenu
    else
        echo ""
        echo -e "\033[1;31mOpcao invalida !\033[0m"
        sleep 1
        proxy
    fi
}

while true; do
    clear
    
    # Captura as informações do sistema
    OS=$(lsb_release -d | cut -f2)  # Obtém o nome da distribuição do sistema operacional
    RAMtotal=$(awk '/MemTotal/ {print $2/1024}' /proc/meminfo)  # Obtém a quantidade total de RAM em megabytes
    CPUcores=$(grep -c '^processor' /proc/cpuinfo)  # Obtém o número de núcleos do processador

    # Captura as informações de uso de CPU e memória
    RAMusado=$(free -m | awk '/^Mem:/ {print $3}')
    CPUusado=$(top -bn1 | grep "Cpu(s)" | awk '{print $2 + $4}')

    # Obtém a hora atual
    hora=$(date +"%T")

    # Script para verificar se há portas ativas no proxy
    screens=$(screen -ls | awk '/\.proxy/ {print $1}')

    # Verificar se há portas ativas
    if [[ -n "$screens" ]]; then
        var_proxy="\033[1;32m(◉)"  # Se houver portas ativas, definir como ativo
    else
        var_proxy="\033[1;31m(○)"  # Se não houver portas ativas, definir como desativado
    fi
    
    var_sks1=$(ps x | grep "udpvpn" | grep -v grep > /dev/null && echo -e "\033[1;32m(◉) " || echo -e "\033[1;31m(○)")
    
    stssl=$(ps x | grep "stunnel" | grep -v grep > /dev/null && echo -e "\033[1;32m(◉) " || echo -e "\033[1;31m(○)")
    
    port=8888

    # Verifique se a porta está em uso
    if lsof -i :$port | grep -q "python3"; then
        var_check="\033[1;32m(◉) "
    else
        var_check="\033[1;31m(○)"
    fi
    
    # Verifique se a porta está em uso
    if ps aux | grep -q "[w]ebsocket"; then
        var_wss="\033[1;32m(◉) "  # Serviço Websocket está ativo
    else
        var_wss="\033[1;31m(○)"   # Serviço Websocket não está ativo
    fi

   # Script 1: Check and display UDPVPN port
    if ps x | grep -w udpvpn | grep -v grep 1>/dev/null 2>/dev/null; then
        echo -e "\033[1;32mBADVPN: \033[1;37m$(netstat -nplt | grep 'badvpn-ud' | awk '{print $4}' | cut -d: -f2 | xargs)"
    else
        sleep 0.1
    fi

    # Script 1: Check and display SSL port
    if ps x | grep -w stunnel | grep -v grep 1>/dev/null 2>/dev/null; then
        echo -e "\033[1;32mSSL:    \033[1;37m$(netstat -nplt | grep 'stunnel' | awk '{print $4}' | cut -d: -f2 | xargs)"
    else
        sleep 0.1
    fi

    # Display WebSocket port
    ws_port=$(netstat -nplt | grep 'websocket' | awk '{print $4}' | cut -d: -f2 | xargs)
    if [ ! -z "$ws_port" ]; then
        echo -e "\033[1;32mWEBSOCKET: \033[1;37m$ws_port"
    fi

    # Script 2: List screen ports
    screens=$(screen -ls | awk '/\.proxy/ {print $1}')
    if [[ -n "$screens" ]]; then
        num_screens=$(echo "$screens" | wc -l)
        for ((i=1; i<=num_screens; i++)); do
            screen_name=$(echo "$screens" | sed -n "$i"p)
            screen_process_id=$(echo "$screen_name" | cut -d'.' -f1)
            screen_num=$(screen -ls | awk '/'"$screen_process_id"'/ {print $1}' | cut -d'.' -f2)
            if [[ $i -eq 1 ]]; then
                echo -n -e "\033[1;32mPROXY:  \033[1;37m$screen_num\033[0m"
            else
                echo -n -e " \033[1;37m$screen_num\033[0m"
            fi
            if ((i%5==0)); then
                echo -e "\n"
            fi
        done
        echo -e "\n"
    fi
    
    echo -e "\033[1;31m╔══════════════════════════════════════╗\033[0m"
    echo -e "\033[1;31m║\033[1;34mSISTEMA     \033[1;37m$OS        \033[1;31m║\033[0m"
    echo -e "\033[1;31m╠══════════════════════════════════════╣\033[0m"
    echo -e "\033[1;31m║\033[1;37mMEMORIA RAM            PROCESSADOR    \033[1;31m║\033[0m"
    echo -e "\033[1;31m║\033[1;34mTotal: \033[1;37m${RAMtotal} MB      \033[1;34mNucleos: \033[1;37m$CPUcores     \033[1;31m║\033[0m"
    echo -e "\033[1;31m║\033[1;34mEm Uso: \033[1;37m${RAMusado} MB        \033[1;34mEm Uso: \033[1;37m${CPUusado}%  \033[1;31m║\033[0m"
    
    echo -e "\033[1;31m╠══════════════════════════════════════╣\033[0m"
    echo -e "\033[01;31m║\E\033[44;1;37m             PROXY LOCKED             \E\033[0m\033[01;31m║"
    echo -e "\033[1;31m╠══════════════════════════════════════╣\033[0m"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m01\033[1;31m] \033[1;37m• \033[1;33mPROXY     $var_proxy \033[1;31m                ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m02\033[1;31m] \033[1;37m• \033[1;33mBAD VPN   $var_sks1 \033[1;31m                ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m03\033[1;31m] \033[1;37m• \033[1;33mCHECKUSER $var_check \033[1;31m                ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m04\033[1;31m] \033[1;37m• \033[1;33mSSL       $stssl \033[1;31m                ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m05\033[1;31m] \033[1;37m• \033[1;33mWEBSOCKET $var_wss \033[1;31m                ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m06\033[1;31m] \033[1;37m• \033[1;33mAPONTAMENTO \033[1;31m                  ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m07\033[1;31m] \033[1;37m• \033[1;33mREMOVER SCRIPT \033[1;31m               ║"
    echo -e "\033[1;31m║ \033[1;31m[\033[1;34m00\033[1;31m] \033[1;37m• \033[1;31mSAIR\033[0m \033[1;31m                         ║"
    echo -e "\033[1;31m╚══════════════════════════════════════╝\033[0m"

    read -p "ESCOLHA UMA OPÇÃO: " opcao

    if [[ "$opcao" == '1' ]]; then
        proxy
        sleep 2s
    elif [[ "$opcao" == '2' ]]; then
        badvpn
        sleep 2s
    elif [[ "$opcao" == '3' ]]; then
        pcheckuser
        sleep 2s
    elif [[ "$opcao" == '4' ]]; then
        ssl
        sleep 2s
    elif [[ "$opcao" == '5' ]]; then
        websocket
        sleep 2s
    elif [[ "$opcao" == '6' ]]; then
        cloudflare
        sleep 2s
    elif [[ "$opcao" == '7' ]]; then
        remover
        sleep 2s
    elif [[ "$opcao" == '0' ]]; then
        echo "Programa encerrado."
        break
    else
        echo "Opção inválida."
        sleep 2s
    fi
done